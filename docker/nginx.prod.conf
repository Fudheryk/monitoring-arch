# =============================================================================
# NGINX CONFIG - PRODUCTION
# neonmonitor.dockl.com
#
# Objectifs:
# 1. neonmonitor.dockl.com : application compl√®te (HTTP->HTTPS + reverse proxy)
# 2. michevre1.vps.webdock.cloud : Hello World simple (HTTP + HTTPS)
# 3. Tout le reste (IP directes, autres domaines) : blocage silencieux
#
# Features:
# - HTTP -> HTTPS + ACME challenge (Certbot) pour neonmonitor.dockl.com
# - reverse proxy /api/* vers api_backend, / vers web_backend
# - headers s√©curit√© + gzip + timeouts + buffering
# - rate limiting global (api/web) + rate limiting d√©di√© ingest
# - logs riches (remote_addr + xff + request_id) pour diagnostiquer
#
# NOTE IMPORTANT (c√¥t√© API / Uvicorn):
# - Pour que FastAPI voit l'IP r√©elle:
#   - lancer uvicorn avec --proxy-headers
#   - configurer forwarded-allow-ips (ex: 127.0.0.1,172.30.0.0/16)
# - Et surtout: nginx doit envoyer X-Forwarded-For / X-Real-IP (fait ci-dessous).
# =============================================================================

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # -------------------------------------------------------------------------
    # WebSocket/SSE safe defaults
    # - Evite les surprises si un jour web ou api utilise Upgrade (WebSocket)
    # - Pour HTTP/1.1, Nginx a besoin d'un Connection correct
    # -------------------------------------------------------------------------
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # -------------------------------------------------------------------------
    # Logs (format enrichi)
    # - remote_addr : IP vue par nginx (souvent la vraie IP client)
    # - xff         : cha√Æne X-Forwarded-For (utile si CDN / LB en amont)
    # - rid         : request_id nginx, propag√© vers l'API et le web
    # -------------------------------------------------------------------------
    log_format main '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent" '
                    'xff="$http_x_forwarded_for" rid="$request_id"';

    access_log /var/log/nginx/access.log main;
    error_log  /var/log/nginx/error.log warn;

    # -------------------------------------------------------------------------
    # Rate limiting config
    # - Renvoyer 429 au lieu de 503 par d√©faut quand la limite est d√©pass√©e
    # -------------------------------------------------------------------------
    limit_req_status 429;

    # -------------------------------------------------------------------------
    # Performances
    # -------------------------------------------------------------------------
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # -------------------------------------------------------------------------
    # Gzip compression
    # -------------------------------------------------------------------------
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript
               application/json application/javascript application/xml+rss;

    # -------------------------------------------------------------------------
    # Rate limiting zones
    # - api_limit   : limite globale sur /api/
    # - web_limit   : limite globale sur /
    # - ingest_limit: limite d√©di√©e sur /api/v1/ingest/* (endpoint sensible)
    #
    # IMPORTANT:
    # - Attention aux IP NAT (plusieurs agents derri√®re la m√™me IP) :
    #   un rate trop bas peut g√©n√©rer des 429.
    # -------------------------------------------------------------------------
    limit_req_zone $binary_remote_addr zone=api_limit:10m    rate=10r/s;
    limit_req_zone $binary_remote_addr zone=web_limit:10m    rate=30r/s;
    limit_req_zone $binary_remote_addr zone=ingest_limit:10m rate=10r/s;

    # -------------------------------------------------------------------------
    # Upstream backends
    # -------------------------------------------------------------------------
    upstream api_backend {
        server api:8000 max_fails=3 fail_timeout=30s;
        keepalive 32; # connexions persistantes vers l'API (perf)
    }

    upstream web_backend {
        server web:3000 max_fails=3 fail_timeout=30s;
        keepalive 32; # connexions persistantes vers le web (perf)
    }

    # =========================================================================
    # HTTP (PORT 80) - Gestion des 3 cas
    # =========================================================================

    # -------------------------------------------------------------------------
    # BLOC HTTP 1: neonmonitor.dockl.com - Redirect vers HTTPS + ACME
    # -------------------------------------------------------------------------
    server {
        listen 80;
        server_name neonmonitor.dockl.com;

        # Certbot ACME challenge (LetsEncrypt) - doit √™tre accessible sur HTTP
        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
        }

        # Tout le reste redirige vers HTTPS
        location / {
            return 301 https://$host$request_uri;
        }
    }

    # -------------------------------------------------------------------------
    # BLOC HTTP 2: michevre1.vps.webdock.cloud - Hello World (HTTP seulement)
    # -------------------------------------------------------------------------
    server {
        listen 80;
        server_name michevre1.vps.webdock.cloud;

        location / {
            default_type text/html;
            return 200 '<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World - VPS</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 600px; margin: 0 auto; }
        h1 { color: #333; }
        p { color: #666; }
        .info { background: #e3f2fd; padding: 15px; border-radius: 4px; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê Hello World</h1>
        <p>Bienvenue sur le VPS de d√©veloppement</p>
        <div class="info">
            <strong>Serveur:</strong> michevre1.vps.webdock.cloud<br>
            <strong>Status:</strong> ‚úÖ Op√©rationnel
        </div>
    </div>
</body>
</html>';
        }
    }

    # -------------------------------------------------------------------------
    # BLOC HTTP 3: Catch-all - Blocage silencieux (IP directes, autres domaines)
    # -------------------------------------------------------------------------
    server {
        listen 80 default_server;
        server_name _;

        # 444 = Nginx ferme la connexion sans envoyer de r√©ponse
        # Utilis√© pour bloquer silencieusement les scanners, bots, acc√®s IP directe
        return 444;
    }

    # =========================================================================
    # HTTPS (PORT 443) - Gestion des 3 cas
    # =========================================================================

    # -------------------------------------------------------------------------
    # BLOC HTTPS 1: neonmonitor.dockl.com - APPLICATION PRINCIPALE
    # -------------------------------------------------------------------------
    server {
        listen 443 ssl;
        http2 on;
        server_name neonmonitor.dockl.com;

        # ---------------------------------------------------------------------
        # SSL Configuration - Certificat Let's Encrypt
        # ---------------------------------------------------------------------
        ssl_certificate     /etc/nginx/certs/live/neonmonitor.dockl.com/fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/live/neonmonitor.dockl.com/privkey.pem;

        # SSL Security (Mozilla Intermediate - compatible et s√©curis√©)
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # ---------------------------------------------------------------------
        # Security Headers
        # ---------------------------------------------------------------------
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # ---------------------------------------------------------------------
        # Rate limiting configuration
        # ---------------------------------------------------------------------
        limit_req_status 429;
        default_type application/json;

        # Page d'erreur personnalis√©e pour rate limiting (JSON)
        error_page 429 = @rate_limited;
        location @rate_limited {
            return 429 '{"detail":"rate limit exceeded"}';
        }

        # =====================================================================
        # LOCATION 1: Ingest Endpoint (prioritaire - haute priorit√©)
        # - Utilise ^~ pour priorit√© maximale (trait√© avant les regex)
        # - Couvre /api/v1/ingest/metrics et futurs endpoints ingest
        # =====================================================================
        location ^~ /api/v1/ingest/ {
            # Rate limiting d√©di√© pour ingest (plus permissif en burst)
            limit_req zone=ingest_limit burst=60 nodelay;

            # Client body buffering (optimis√© pour ingest)
            # - Evite d'√©crire le body sur disque pour des payloads ~512KB
            # - Garde une limite de s√©curit√© (ajuste selon worst-case)
            client_body_buffer_size 1m;
            client_max_body_size 2m;

            # Proxy vers API backend
            proxy_pass http://api_backend;
            proxy_http_version 1.1;

            # Headers (IMPORTANT pour que FastAPI voit l'IP r√©elle)
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;

            # Request ID (corr√©lation logs nginx <-> api)
            proxy_set_header X-Request-Id $request_id;

            # WebSocket/SSE safe (au cas o√π)
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # Timeouts (60s pour ingestion potentiellement volumineuse)
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;

            # Optionnel: d√©sactiver les logs si ingest trop verbeux
            # access_log off;
        }

        # =====================================================================
        # LOCATION 2: API Routes g√©n√©rales (/api/*)
        # - Rate limit global sur /api/
        # - NOTE: ingest est trait√© par le bloc pr√©c√©dent (^~ prioritaire)
        # =====================================================================
        location /api/ {
            # Rate limiting global API
            limit_req zone=api_limit burst=20 nodelay;

            # Proxy vers API backend
            proxy_pass http://api_backend;
            proxy_http_version 1.1;

            # Headers (IMPORTANT pour IP r√©elle)
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Request-Id $request_id;

            # WebSocket/SSE safe
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # Timeouts standards pour API
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;

            # Buffering (r√©ponses API normalement pas trop grosses)
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
        }

        # =====================================================================
        # LOCATION 3: Static Files Caching
        # - Cache c√¥t√© client (1 jour)
        # - Pour un vrai cache nginx: ajouter proxy_cache_path + proxy_cache
        # =====================================================================
        location /static/ {
            proxy_pass http://web_backend;
            proxy_http_version 1.1;

            # Cache client-side
            add_header Cache-Control "public, max-age=86400";
            expires 1d;
        }

        # =====================================================================
        # LOCATION 4: Health Checks (pas de rate limit, pas de logs)
        # =====================================================================
        location ~ ^/(api/v1/)?health$ {
            proxy_pass http://api_backend;
            access_log off;
        }

        location /_health {
            proxy_pass http://web_backend;
            access_log off;
        }

        # =====================================================================
        # LOCATION 5: Web Application (/) - DOIT √äTRE EN DERNIER
        # - Catch-all pour toutes les routes non match√©es
        # =====================================================================
        location / {
            # Rate limiting global web
            limit_req zone=web_limit burst=50 nodelay;

            # Proxy vers web backend
            proxy_pass http://web_backend;
            proxy_http_version 1.1;

            # Headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Request ID (debug full-chain)
            proxy_set_header X-Request-Id $request_id;

            # WebSocket/SSE safe (si UI en a besoin - ex: hot reload)
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;

            # Timeouts standards pour web
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }
    }

    # -------------------------------------------------------------------------
    # BLOC HTTPS 2: michevre1.vps.webdock.cloud - Hello World
    # -------------------------------------------------------------------------
    server {
        listen 443 ssl;
        http2 on;
        server_name michevre1.vps.webdock.cloud;

        # SSL Configuration
        # NOTE: Utilise le certificat de neonmonitor.dockl.com
        # Le navigateur affichera un avertissement car le certificat ne correspond pas
        # C'est normal et attendu pour ce domaine secondaire
        ssl_certificate     /etc/nginx/certs/live/neonmonitor.dockl.com/fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/live/neonmonitor.dockl.com/privkey.pem;

        # SSL Security
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;

        # Hello World
        location / {
            default_type text/html;
            return 200 '<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello World - VPS (HTTPS)</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-width: 600px; margin: 0 auto; }
        h1 { color: #333; }
        p { color: #666; }
        .info { background: #e3f2fd; padding: 15px; border-radius: 4px; margin-top: 20px; }
        .warning { background: #fff3cd; padding: 15px; border-radius: 4px; margin-top: 20px; border-left: 4px solid #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Hello World (HTTPS)</h1>
        <p>Bienvenue sur le VPS de d√©veloppement (connexion s√©curis√©e)</p>
        <div class="info">
            <strong>Serveur:</strong> michevre1.vps.webdock.cloud<br>
            <strong>Protocole:</strong> HTTPS<br>
            <strong>Status:</strong> ‚úÖ Op√©rationnel
        </div>
        <div class="warning">
            ‚ö†Ô∏è <strong>Note:</strong> Le certificat SSL est celui de neonmonitor.dockl.com<br>
            Votre navigateur peut afficher un avertissement de s√©curit√©, c\'est normal.
        </div>
    </div>
</body>
</html>';
        }
    }

    # -------------------------------------------------------------------------
    # BLOC HTTPS 3: Catch-all - Blocage silencieux
    # - Bloque les acc√®s par IP directe ou domaines non autoris√©s
    # - ssl_reject_handshake emp√™che m√™me la n√©gociation SSL
    # -------------------------------------------------------------------------
    server {
        listen 443 ssl default_server;
        server_name _;

        # Rejette la n√©gociation SSL avant m√™me d'√©tablir la connexion
        # Evite les avertissements de certificat et √©conomise les ressources
        ssl_reject_handshake on;
    }
}